#!/usr/bin/ruby
# -*- coding: utf-8 -*-

=begin rdoc
Install
----------

Move into a directory in PATH environment variable.

   $ mv git-ticket /path/to/some/dir
   $ chmod a+x /path/to/some/dir/git-ticket

If you use old ruby(e.g. Ruby 1.8), you should install json library.

   $ gem install json
   $ export RUBYOPT=rubygems

Setup
-----------

Set your redmine root and API Key.

   git config redmine.url http://example.com/redmine
   git config redmine.apikey some_api_key

Usage
-----------

And create topic branch.

   git ticket 42

At topic branch, you could see ticket summary.

   git ticket

This subcommand use bleis-style branch name. Please see also https://github.com/bleis-tift/Git-Hooks/ .
=end

require 'openssl'
require 'uri'
require 'open-uri'
require 'json'
require 'optparse'
require 'pp'


Root = %x(git config redmine.url).strip
ApiKey = %x(git config redmine.apikey).strip
Project = %x(git config redmine.project).strip

if Root.empty? or ApiKey.empty? then
  puts <<-END
please set redmine url & redmine api key

  git config redmine.url http://example.com/redmine
  git config redmine.apikey some_api_key
END
  exit 0
end
# ------------------------------
# main
# ------------------------------
ProgramConfig = {}
opts = OptionParser.new
opts.banner = 'git ticket [options] [id]'
opts.on("-f", "--force","force create branch"){
  ProgramConfig[:force] = true
}
opts.on("-n", "--no-verify", "not verify ssl"){
  OpenSSL::SSL::VERIFY_PEER = OpenSSL::SSL::VERIFY_NONE
}
opts.parse!(ARGV)

unless ARGV.empty?
  ticket, _ = *ARGV
  if ProgramConfig[:force]
    system "git branch -D id/#{ticket}"
  end
  system "git checkout -b id/#{ticket}"
end

branch = %x(git branch -l | grep "*" | cut -d " " -f 2).strip

case branch
when %r!id/(\d+)!
  ticket = $1
  url = URI(Root+"/") + "./issues/#{ticket}.json?key=#{ApiKey}&include=journals"

  begin
    open(url) do |io|
      issue = JSON.parse(io.read)['issue']
      puts <<-END
     id: #{issue['id']}
Subject: #{issue['subject']}
 Author: #{issue['author']['name']}
   Date: #{issue['updated_on']}

#{issue['description']}
    END

      puts "","notes: "
      issue['journals'].each_with_index do |journal, i|
        unless journal['notes'] == ''
          puts <<-END
##{i+1}:
#{journal['notes']}

          END
        end
      end
    end
  rescue => e
    puts "cannot access: #{url}"
    puts e
    puts e.backtrace
  end
when "master"
  url = URI(Root+"/") + "./issues.json?project_id=#{Project}&key=#{ApiKey}"

  begin
    open(url) do |io|
      issues = JSON.parse(io.read)['issues']
      issues.each do|issue|
        puts "#{issue['id']} #{issue['subject'].gsub("\n","")}"
      end
    end
  rescue => e
    puts "cannot access: #{url}"
    puts e
    puts e.backtrace
  end
end
