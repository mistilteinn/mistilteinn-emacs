#!/usr/bin/ruby
# -*- coding: utf-8 -*-
require 'uri'
require 'open-uri'
require 'json'
require 'pp'
require 'net/http'
require 'net/https'
require 'yaml'
require 'tempfile'

class Git
  class Config
    def set(name, value)
      %x(git config #{name} "#{value}")
    end

    def get(name)
      val = %x(git config #{name}).strip
      if val.empty? then nil else val end
    end
    
    def getByRegexp(regex)
      %x(git config --get-regexp #{regex}).split(/\n/).map do |line|
        line.match(/(.+?) (.*)/)[1..2]
      end
    end
  end

  def initialize
    @config = Config.new
  end
  attr_reader :config

  def branch
    %x(git branch -l | grep "*" | cut -d " " -f 2).strip
  end

  def ticket_id
    $1 if branch =~ %r!id/(\d+)!
  end
end

class Redmine
  class ConfigError < StandardError; end

  def initialize(git)
    @root    = git.config.get "redmine.url"
    @key     = git.config.get "redmine.apikey"
    @project = git.config.get "redmine.project"

    unless @root and @key and @project
      raise ConfigError.new
    end
  end

  def tickets
    api("issues", :project_id => @project)['issues']
  end

  def summary(id)
    issue = api("issues/#{id}", :include => "journals")["issue"]
    "\##{issue['id']} #{issue['subject']}"
  end

  def info(id)
    issue = api("issues/#{id}", :include => "journals")["issue"]
    body = <<-END
     ID: #{issue['id']}
Subject: #{issue['subject']}
 Author: #{issue['author']['name']}
   Date: #{issue['updated_on']}
    END

    unless issue['description'].empty?
      body << "\n"
      body << issue['description']
    end

    unless issue['journals'].empty?
      body << "\n\nnotes:\n"

      issue['journals'].each_with_index do |journal, i|
        unless journal['notes'] == ''
          body << <<-END
##{i+1}:
#{journal['notes']}
          END
        end
      end
    end

    body
  end

  def create(title)
    post('issues', {}, {
           :issue => {
             :project_id => @project,
             :subject => title,
           }}.to_json)
  end

  def api(path, params = {})
    params[:key] = @key if @key
    url = URI(@root+"/") + ("./#{path}.json?" + params.map{|key,value| "#{key}=#{value}" }.join("&"))

    begin
      open(url) do |io|
        JSON.parse(io.read)
      end
    rescue => e
      puts "cannot access: #{url}"
      raise e
    end
  end

  def post(path, params, data)
    url = URI(@root+"/") + "./#{path}.json?"

    http = Net::HTTP.new(url.host, url.port)
    http.use_ssl = url.scheme == 'https'

    http.start do
      ret = http.post(url.path,data, {
                        "X-Redmine-API-Key" => @key,
                        "Content-Type" => "application/json"
                      })
      case ret
      when Net::HTTPSuccess
      else
        raise "error: #{ret}"
      end
    end
  end
end

class GitConfigITS
  class ConfigError < StandardError; end

  def initialize(git)
    @git = git
  end
  
  def tickets
    lastTicketNo = @git.config.get("ticket.ticketNo").to_i
    (1...lastTicketNo).map do |id|
      data = {}
      @git.config.getByRegexp("ticket\\.id/#{id}").each do |name, title|
        name.sub!("ticket.id/#{id}.", "")
        data[name] = title
      end
      {'id' => id, 'subject' => data["title"],
        'status' => {'name' => data["status"]}}
    end
  end

  def summary(id)
  end

  def info(id)
    body = <<-END
     ID: #{id}
Subject: #{@git.config.get "ticket.id/#{id}.title"}
 Author: #{@git.config.get "ticket.id/#{id}.author"}
   Date: #{@git.config.get "ticket.id/#{id}.date"}
#{@git.config.get "ticket.id/#{id}.description"}
    END
  end

  def create(title = "")
    ticketFormat = <<END
title: #{title}
author: #{@git.config.get "user.name"}
date: #{Time.now}
status: new
description: |-
  
END

    editTempFile(ticketFormat) do |f, modified|
      return if not modified and title.empty?

      ticketNo = (@git.config.get("ticket.ticketNo") || "1").to_i
      YAML.load_documents(f) do |yaml|
        yaml.each do |key, value|
          @git.config.set("ticket.id/#{ticketNo}.#{key}", value)
        end
      end
      @git.config.set("ticket.ticketNo", (ticketNo+1).to_s)
    end
  end

  def edit(id)
  end

  private
  def editTempFile(initialString, &proc)
    tmp = Tempfile.new("tmp")
    tmp.write initialString
    tmp.close

    editor = @git.config.get("core.editor") || ENV["EDITOR"]
    system "#{editor} #{tmp.path}"
    File.open(tmp.path) do |f|
      modified = f.read != initialString
      f.rewind
      proc.call(f, modified)
    end
    tmp.unlink
  end
end

class GitTicket
  def initialize(git, its)
    @git = git
    @its = its
  end

  def cmd_list
    @its.tickets.each do|ticket|
      puts "#{ticket['id']} #{ticket['subject']} [#{ticket['status']['name']}]"
    end
  end

  def cmd_summary(id = @git.ticket_id)
    puts @its.summary(id)
  end

  def cmd_info(id = @git.ticket_id)
    puts @its.info(id)
  end

  def cmd_switch(id)
    branch = "id/#{id}"
    unless system "git checkout #{branch}" then
      system "git checkout -b #{branch}"
    end
    puts "Switch to topic branch: #{@its.summary(id)}"
  end

  def cmd_create(title)
    @its.create title
  end

  def default(args)
    if args.empty?
      case @git.branch
      when %r!id/(\d+)!
        cmd_info
      else
        cmd_list
      end
    else
      cmd_switch(*args)
    end
  end
end

git = Git.new

begin
  case git.config.get "ticket.its"
  when 'redmine'
    its = Redmine.new git
  when 'local'
    its = GitConfigITS.new git
  else
    # todo: error handling
    STDERR.puts "no its specifed"
    exit 1
  end
  git_ticket = GitTicket.new git, its

  cmd = "cmd_#{ARGV.first}".to_sym
  if git_ticket.respond_to? cmd then
    git_ticket.send cmd, *ARGV[1..-1]
  else
    git_ticket.default(ARGV)
  end
# rescue
#   STDERR.puts <<END
# # This repository is not configured. Please set redmine information.

# git config redmine.url http://example.com/Redmine
# git config redmine.apikey some_api_key
# git config redmine.project project_name
# END
#   exit 1
end

