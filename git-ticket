#!/usr/bin/ruby
# -*- coding: utf-8 -*-
require 'uri'
require 'open-uri'
require 'json'
require 'pp'
require 'net/http'
require 'net/https'

class Git
  def config(name)
    str = %x(git config #{name} 2>/dev/null || echo "").strip
    if str.empty? then
      nil
    else
      str
    end
  end

  def branch
    %x(git branch -l | grep "*" | cut -d " " -f 2).strip
  end

  def ticket_id
    $1 if branch =~ %r!id/(\d+)!
  end
end

class Redmine
  class ConfigError < StandardError; end

  def initialize(git)
    @root    = git.config "redmine.url"
    @key     = git.config "redmine.apikey"
    @project = git.config "redmine.project"

    unless @root and @key and @project
      raise ConfigError.new
    end
  end

  def tickets
    api("issues", :project_id => @project)['issues']
  end

  def summary(id)
    issue = api("issues/#{id}", :include => "journals")["issue"]
    "\##{issue['id']} #{issue['subject']}"
  end

  def info(id)
    issue = api("issues/#{id}", :include => "journals")["issue"]
    body = <<-END
     ID: #{issue['id']}
Subject: #{issue['subject']}
 Author: #{issue['author']['name']}
   Date: #{issue['updated_on']}
    END

    unless issue['description'].empty?
      body << "\n"
      body << issue['description']
    end

    unless issue['journals'].empty?
      body << "\n\nnotes:\n"

      issue['journals'].each_with_index do |journal, i|
        unless journal['notes'] == ''
          body << <<-END
##{i+1}:
#{journal['notes']}
          END
        end
      end
    end

    body
  end

  def create(title)
    post('issues', {}, {
           :issue => {
             :project_id => @project,
             :subject => title,
           }}.to_json)
  end

  def api(path, params = {})
    params[:key] = @key if @key
    url = URI(@root+"/") + ("./#{path}.json?" + params.map{|key,value| "#{key}=#{value}" }.join("&"))

    begin
      open(url) do |io|
        JSON.parse(io.read)
      end
    rescue => e
      puts "cannot access: #{url}"
      raise e
    end
  end

  def post(path, params, data)
    url = URI(@root+"/") + "./#{path}.json?"

    http = Net::HTTP.new(url.host, url.port)
    http.use_ssl = url.scheme == 'https'

    http.start do
      ret = http.post(url.path,data, {
                        "X-Redmine-API-Key" => @key,
                        "Content-Type" => "application/json"
                      })
      case ret
      when Net::HTTPSuccess
      else
        raise "error: #{ret}"
      end
    end
  end
end

class Github
  class ConfigError < StandardError; end

  API_URL_ROOT = "https://api.github.com/"

  def initialize(git)
    @url = git.config "github.url"
    unless @url
      raise ConfigError.new
    end
  end

  def tickets
    api("issues").map do |issue|
      {
        'id' => issue['number'],
        'subject' => issue['title'],
        'status' => {'name' => issue['state']}
      }
    end
  end

  def summary(id)
    issue = api("issues/#{id}")
    "\##{issue['number']} #{issue['title']}"
  end

  def info(id)
    issue = api("issues/#{id}")
    body = <<-END
     ID: #{issue['number']}
Subject: #{issue['title']}
 Author: #{issue['user']['login']}
   Date: #{issue['updated_at']}
    END

    unless issue['body'].empty?
      body << "\n"
      body << issue['body']
    end

    comments = api("issues/#{id}/comments")
    unless comments.nil?
      body << "\n\nnotes:\n"

      comments.each_with_index do |comment, i|
        unless comment['body'] == ''
          body << <<-END
##{i+1}:
#{comment['body']}
          END
        end
      end
      body
    end

    body
  end

  def create(title)
    # TODO
  end

  def api(api_name, params = {})
    api_uri = URI(API_URL_ROOT) + "./repos/" + ("./" + URI(@url).path)
    url = api_uri + ("./#{api_name}?" + params.map{|key,value| "#{key}=#{value}" }.join("&"))
    begin
      open(url) {|io| JSON.parse(io.read)}
    rescue => e
      puts "cannot access: #{url}"
      raise e
    end
  end
end

class GitTicket
  def initialize(git, its)
    @git = git
    @its = its
  end

  def cmd_list
    @its.tickets.each do|ticket|
      puts "#{ticket['id']} #{ticket['subject']} [#{ticket['status']['name']}]"
    end
  end

  def cmd_summary(id = @git.ticket_id)
    puts @its.summary(id)
  end

  def cmd_info(id = @git.ticket_id)
    puts @its.info(id)
  end

  def cmd_switch(id)
    branch = "id/#{id}"
    unless system "git checkout #{branch}" then
      system "git checkout -b #{branch}"
    end
    puts "Switch to topic branch: #{@its.summary(id)}"
  end

  def cmd_create(title)
    @its.create title
  end

  def default(args)
    if args.empty?
      case @git.branch
      when %r!id/(\d+)!
        cmd_info
      else
        cmd_list
      end
    else
      cmd_switch(*args)
    end
  end
end

git = Git.new

begin
  its = Redmine.new git
  git_ticket = GitTicket.new git, its

  cmd = "cmd_#{ARGV.first}".to_sym
  if git_ticket.respond_to? cmd then
    git_ticket.send cmd, *ARGV[1..-1]
  else
    git_ticket.default(ARGV)
  end
rescue
  STDERR.puts <<END
This repository is not configured. Please set redmine information.

git config redmine.url http://example.com/Redmine
git config redmine.apikey some_api_key
git config redmine.project project_name
END
  exit 1
end

